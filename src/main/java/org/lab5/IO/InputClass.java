package org.lab5.IO;

import org.lab5.annotations.Skip;
import org.lab5.models.Model;
import org.lab5.scheme.FieldSchema;
import org.lab5.scheme.Schema;
import org.lab5.scheme.TypeSchema;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.ZonedDateTime;
import java.util.Arrays;
import java.util.Date;
import java.util.List;

import static org.lab5.Validator.validateField;

/**

 * A utility class for handling input operations.
 */
public class InputClass {

    private static final String[] PRIMITIVE_NAMES = new String[]{"boolean", "byte", "char", "double", "float",
            "int", "long", "short", "void"};
    private static final Class<?>[] PRIMITIVE_CLASSES = new Class[]{Boolean.class, Byte.class, Character.class,
            Double.class, Float.class, Integer.class, Long.class, Short.class, Void.class};
    private static final int PRIMITIVE_CLASS_NAME_MAX_LENGTH = 7;
    static public long id = 0;

    /**
     * Returns the corresponding class object for a primitive type given its name.
     *
     * @param name the name of the primitive type
     * @return the class object corresponding to the primitive type or null if the name is not a primitive type
     */
    public static Class<?> getPrimitiveClass(String name) {
        if (name.length() <= PRIMITIVE_CLASS_NAME_MAX_LENGTH) {
            int index = Arrays.binarySearch(PRIMITIVE_NAMES, name);
            if (index >= 0) {
                return PRIMITIVE_CLASSES[index];
            }
        }
        return null;
    }

    /**
     * Returns an array of all the enum values of a given enum class.
     *
     * @param enumClass the enum class
     * @return an array of all the enum values of the given enum class
     * @throws NoSuchFieldException if the enum class does not have a field named "$VALUES"
     * @throws IllegalAccessException if the enum class's "$VALUES" field is inaccessible
     */
    private static <E extends Enum> E[] getEnumValues(Class<?> enumClass) throws NoSuchFieldException, IllegalAccessException {
        Field f = enumClass.getDeclaredField("$VALUES");
        f.setAccessible(true);
        Object o = f.get(null);
        return (E[]) o;
    }

    /**
     * Returns a declared method of a given object with a specified name and parameter types.
     *
     * @param obj the object whose method is to be returned
     * @param name the name of the method
     * @param parameterTypes the parameter types of the method
     * @return the declared method with the specified name and parameter types, or null if no such method exists
     */
    public static Method getDeclaredMethod(Class<?> obj, String name, Class<?>... parameterTypes) {
        try {
            return obj.getDeclaredMethod(name, parameterTypes);
        } catch (NoSuchMethodException | SecurityException e) {
            return null;
        }
    }

    /**
     * Generates an auto-generated value for a field if applicable.
     *
     * @param field the field for which an auto-generated value is to be generated
     * @return the auto-generated value or null if the field does not have an auto-generated value
     */
    static public Object AutoGenerate(Field field) {
        if (field.getName().equals("id"))
            return ++id;
        return LocalDateTime.now();
    }
    /**
     * Parses a single field of an object using reflection based on its FieldSchema representation
     * @param field The FieldSchema representation of the field to be parsed
     * @param reader A BufferedReader object used to read input from the console
     * @param writer A BufferedOutputStream object used to write output to the console
     * @param description A description of the field being parsed
     * @param result The object whose field is being parsed
     * @param update A boolean indicating whether the field is being updated (true) or created (false)
     * @throws IOException if there is an error reading input from the console
     * @throws ReflectiveOperationException if there is an error using reflection to access or set the field
     */
    static public <T> void parseField(FieldSchema field, BufferedReader reader, BufferedOutputStream writer, String description, T result, boolean update) throws IOException, ReflectiveOperationException {
        Class<?> type = field.getType();
        String typeName = type.getName();
        Field fieldReference = field.getFieldReference();

        if (field.isAutoGenerated()) {
            if (update)
                return;
            fieldReference.setAccessible(true);
            fieldReference.set(result, AutoGenerate(fieldReference));
            return;
        }
        if (fieldReference.isAnnotationPresent(Skip.class)) {
            return;
        }

        Method valueOf = field.getValueOf();
        if (valueOf != null || typeName.equals("java.lang.String")) {
            while (true) {
                writer.write((description + field.getPrompt() + (update ? "[Текущее значение -  " + fieldReference.get(result) + " ] " : "")).getBytes(StandardCharsets.UTF_8));
                writer.flush();

                String line = reader.readLine();
                if (line.isBlank()) {
                    if (update)
                        break;
                    line = null;
                }

                String validation = validateField(field,line);
                if(validation != null){
                    writer.write((validation).getBytes(StandardCharsets.UTF_8));
                    continue;
                }
                if(line == null){
                    ((Model)result).setField(field.getName(),null);
                    break;
                }

                Object value = typeName.equals("java.lang.String") ? line : valueOf.invoke(null, line);
                if(value != null && typeName.equals("java.lang.String") && (((String) value).contains(";") || ((String) value).contains("\""))){
                    writer.write(("Вы использовали запрещенный символ\n").getBytes(StandardCharsets.UTF_8));
                    continue;
                }

                //((Model)result).setField(fieldReference.getName(),value);
                fieldReference.set(result, value);
                break;
            }
        } else {
            writer.write((field.getPrompt() + "\n").getBytes(StandardCharsets.UTF_8));
            writer.flush();
            Constructor<?> constructor = type.getConstructor();
            Object fieldValue;
            if (!update)
                fieldValue = parse(typeName, reader, writer, description + field.getName() + "-> ", constructor, null);
            else
                fieldValue = parse(typeName, reader, writer, description + field.getName() + "-> ", constructor, fieldReference.get(result));

            fieldReference.set(result, fieldValue);
        }
    }

    /**
     * Parse method for parsing input into object of given class name with the help of TypeSchema
     * @param className name of the class
     * @param reader reader object to read input from
     * @param writer writer object to write output to
     * @param description description to display before each prompt
     * @param constructor constructor object to create new instance of the given class
     * @param obj instance of the class to fill with data, null if new instance is to be created
     * @param <T> type of the class
     * @return instance of the given class filled with data
     * @throws ReflectiveOperationException if any error occurs while performing reflection
     */
    static public <T> T parse(String className, BufferedReader reader, BufferedOutputStream writer, String description, Constructor<?> constructor, T obj) throws ReflectiveOperationException {
        TypeSchema schema = Schema.get(className);
        List<FieldSchema> fields = schema.getFields();
        T result;
        if (obj == null)
            result = (T) constructor.newInstance();
        else
            result = obj;

        for (var field : fields) {
            while (true) {
                try {
                    parseField(field, reader, writer, description, result, obj != null);
                    break;
                } catch (Exception e) {
                    System.out.println("Вы ввели некоректные данные повторите попытку.");
                }
            }
        }

        return result;
    }
}
